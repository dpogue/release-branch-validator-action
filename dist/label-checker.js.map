{"version":3,"file":"label-checker.js","sourceRoot":"","sources":["../src/label-checker.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,IAAI,MAAM,eAAe,CAAC;AAGtC,OAAO,EAAE,iBAAiB,EAAE,yBAAyB,EAAE,0BAA0B,EAAE,MAAM,UAAU,CAAC;AAEpG,MAAM,UAAU,WAAW,CAAC,CAAC,SAAS,EAAE,WAAW,EAAE,YAAY,CAAgD;IAC/G,6DAA6D;IAC7D,MAAM,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAA4B,CAAC;IACjH,MAAM,aAAa,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,EAAE,MAAM,CAAC,EAAE,EAAE,CAAC,KAAK,CAAC,CAAC;IAEjE,qEAAqE;IACrE,MAAM,eAAe,GAAG,WAAW,CAAC,GAAG,CAA0B,CAAC,CAAC,EAAE,EAAE,MAAM,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAExI,sDAAsD;IACtD,MAAM,gBAAgB,GAAG,eAAe,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,MAAM,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,MAAM,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC;IACjH,IAAI,gBAAgB,CAAC,MAAM,GAAG,CAAC,EAAE;QAC/B,OAAO,OAAO,CAAC,MAAM,CAAC,IAAI,iBAAiB,CAAC,gDAAgD,EAAE,gBAAgB,CAAC,CAAC,CAAC;KAClH;IAED,MAAM,QAAQ,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,MAAM,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAEhF,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;QACzB,OAAO,OAAO,CAAC,MAAM,CAAC,IAAI,yBAAyB,CAAC,mDAAmD,EAAE,QAAQ,CAAC,CAAC,CAAC;KACrH;IAED,MAAM,cAAc,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,EAAE,MAAM,CAAC,EAAE,EAAE,CAAC,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,EAAE,MAAM,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IACzH,IAAI,CAAC,KAAK,CAAC,0CAA0C,cAAc,qBAAqB,YAAY,EAAE,CAAC,CAAC;IAExG,IAAI,cAAc,KAAK,YAAY,EAAE;QACnC,OAAO,OAAO,CAAC,MAAM,CAAC,IAAI,0BAA0B,CAAC,cAAc,CAAC,CAAC,CAAC;KACvE;AACH,CAAC","sourcesContent":["import * as core from \"@actions/core\";\nimport { IBranchMapping } from \"./branch-config\";\nimport { IIssueLabelMapping } from \"./issue-fetcher\";\nimport { MissingLabelError, InconsistentReleasesError, IncorrectTargetBranchError } from \"./errors\";\n\nexport function checkLabels([branchMap, issueLabels, targetBranch] : [IBranchMapping, IIssueLabelMapping, string]) {\n  // List of all the labels that are mapped to release branches\n  const releaseMap = Object.keys(branchMap).flatMap(k => branchMap[k].map(b => [b, k])) as Array<[string, string]>;\n  const releaseLabels = releaseMap.map(([label, branch]) => label);\n\n  // Filter each issue's labels to only include ones mapped to releases\n  const issuesByRelease = issueLabels.map<[string, Array<string>]>(([id, labels]) => [id, labels.filter(l => releaseLabels.includes(l))]);\n\n  // Error if issues do not have exactly 1 release label\n  const unlabelledIssues = issuesByRelease.filter(([id, labels]) => labels.length !== 1).map(([id, labels]) => id);\n  if (unlabelledIssues.length > 0) {\n    return Promise.reject(new MissingLabelError(\"Some Jira issues have incorrect release labels\", unlabelledIssues));\n  }\n\n  const releases = [...new Set(issuesByRelease.map(([id, labels]) => labels[0]))];\n\n  if (releases.length !== 1) {\n    return Promise.reject(new InconsistentReleasesError(\"Inconsistent release labelled for included issues\", releases));\n  }\n\n  const intendedBranch = releaseMap.filter(([label, branch]) => label === releases[0]).map(([label, branch]) => branch)[0];\n  core.debug(`This PR should be targeting the branch ${intendedBranch} and is targeting ${targetBranch}`);\n\n  if (intendedBranch !== targetBranch) {\n    return Promise.reject(new IncorrectTargetBranchError(intendedBranch));\n  }\n}\n"]}